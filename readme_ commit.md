#48 大世界的场景复杂度管理方案
===

- 作者: 天美 tianpeng
- 文章分类: 游戏客户端架构和技术

<br>
&emsp;&emsp;大世界，首当其冲的三个问题：规模、复杂度/性能、渲染，分别对应内容生产、内容承载和内容呈现。本文聚焦如何解决内容承载问题，即场景复杂度管理。在大世界场景里，通常有大面积地形，大规模植被，大量琐碎静态物件等，在相同的硬件平台下，复杂度管理模块很大程度上决定了场景里填充内容的数量和质量。<br>
&emsp;&emsp;本文描述的大世界场景复杂度管理模块，基于控制理论里的负反馈系统，分为三个部分：<br>
1、输入部分。包含复杂度降维，复杂度度量，Bucket计算。在引擎和Gameplay层面，根据游戏定制计算因子和权重，统一计算复杂度和Bucket，传递给控制器模块。<br>
2、控制器/被控对象部分。包含Visibility检测，LOD系统，Scalability系统，动态分辨率等。该部分根据输入和反馈信号，利用多种不同的复杂度控制算法综合调节系统当前负荷。<br>
3、输出/反馈部分。用于实现Adaptive Performance。根据系统负荷能力，系统当前负荷以及系统指定负荷，传递反馈信号到控制器模块。
&emsp;&emsp;整个系统，最终可以达成如下几个目标：<br>
1、运行时根据平台设定，智能控制场景内容的加载卸载、显示隐藏、LOD控制等。<br>
2、根据平台负载能力和当前负荷，更有效的控制运行负荷，获取平滑的fps。<br>
<br>
<br>

# 1.概述
&emsp;&emsp;随着硬件平台和游戏技术的不断进步，呈现到玩家手上的游戏品质也在快速提升，尤其是随着手游市场的崛起，近年来呈现了一批品质拔尖的作品。即便这样，依然无法满足玩家对于3A游戏的期待。3A游戏，大部分都是以大世界的形式来表现游戏内容。即便硬件平台的能力在飞速提升，往往也很难满足大世界场景复杂度的爆发式增长。所以如何控制和调节场景复杂度，在很大程度上决定了场景里填充内容的数量和质量。<br>
&emsp;&emsp;下图是一个典型的大世界场景，可以清楚看到，大地型肯定是开放的地图，视野比较宽，视距比较远，地图比较大，还会有比较多的风格变换，导致绘制内容的种类比较多，资源的使用、变化比简单一些的游戏复杂非常多。
![大世界\label{fig:bigWorld}](bigWorld.jpg)
<br>

&emsp;&emsp;为简化我们的算法模型、以及篇幅限制等原因，文中并不会考虑渲染管线、光照、后处理等一些高级渲染话题，因为这些技术的使用，大多都可以根据硬件平台能力和玩家喜好，通过渲染选项进行静态配置。所以文中关于复杂度和控制算法的讨论，都是基于简化后的基础模型特性进行阐述和讨论。<br>
&emsp;&emsp;场景复杂度，从广义上讲，就是有场景对象的数量和内容细节决定。更细化一点，每个对象的内容包括Mesh，纹理，材质等核心要素。<br>
&emsp;&emsp;控制场景复杂度，最终的目标就是要让游戏平滑的运行，并尽量保持低功耗。要达到这样的目的，就要从场景对象消耗的CPU、GPU、内存、带宽方面入手。即控制显示哪些对象，对象的加载与卸载，显示与隐藏，对象的质量(LOD)等。<br>
&emsp;&emsp;根据之前的项目经验，我们往往会使用Visibility检测算法、LOD策略等，来粗暴的决定场景物件的显示和显示质量，没有一个很好的衡量标准来检测有效性和准确性。更没有把这些复杂度控制方法整合到一个统一的系统里面，并通过系统的实际运行数据，来准确或者相对准确的来决定我们使用何种控制手段以及如何控制场景复杂度。<br>
&emsp;&emsp;以上这些，就是我们提出创建一个大世界的场景复杂度控制系统的出发点。<br>

## 1.1 渲染框架
&emsp;&emsp;从游戏运行层面看，硬件平台的核心资源包括：cpu，gpu，内存、带宽（这里特指soc架构的移动平台）。
&emsp;&emsp;现代硬件平台和图形API，总的趋势是并行渲染。UE在此基础上，渲染框架也充分利用了并行的特点，如下图
![渲染框架\label{fig:Parallel_Rendering.png}](Parallel_Rendering.png)
&emsp;&emsp;这个是Renderer Thread和RHI Thread的交互示意图。整个UE引擎的框架，大致可分为：<br>
game thread,负责游戏逻辑，提交cpu渲染数据。<br>
renderer thread，负责排序、剔除、生成渲染命令。<br>
rhi thread，负责生成gpu渲染数据，提交渲染命令<br>
gpu thread，负责执行渲染命令<br>
&emsp;&emsp;UE的手游客户端的性能主要由这七大部分构成：<br>
CPU逻辑，CPU渲染，图形API（提交），GPU渲染，内存，带宽，加载时间。<br>

&emsp;&emsp;这几个基本元素又会合力衍生出一些新的性能指标，例如功耗（往往同gpu负载和带宽紧密相关）。同时这七部分又构成一个闭合的木桶，最长的一块是主要瓶颈，并且瓶颈可以在这几块转移流动。<br>

&emsp;&emsp;首先低帧率和卡顿是两种完全不同的瓶颈类型，虽然归根到底都是某个函数执行的过慢引起的，但是定位和解决方法并不一样。低帧率瓶颈是需要统计一段时间内CPU把更多的时钟耗费在了哪些函数上，或统计一段时间内各个函数占用的cpu时间百分比，找到百分比高的将其优化，就会使帧率得到整体的提高。卡顿则是在一帧的一次运行内某段代码的运行产生了比平均情况明显的长时间，需要定义这段代码的起始点，分别进行计时，然后在连续的统计数据中找到峰值。简单来说帧率瓶颈是统计平均的CPU占用，而卡顿是找峰值。<br>

## 1.1 系统框架
&emsp;&emsp;在工业自动控制理论里，有两种常用的控制系统模型：正反馈和负反馈。若反馈信号与输入信号极性相同或变化方向同相，则两种信号混合的结果将使放大器的净输入信号大于输出信号，这种反馈叫正反馈。正反馈主要用于信号产生电路。反之，反馈信号与输入信号极性相反或变化方向相反（反相），则叠加的结果将使净输入信号减弱，这种反馈叫负反馈放大电路和自动控制系统通常采用负反馈技术以稳定系统的工作状态。
&emsp;&emsp;很显然，我们的目标是在任意平台任意场景下，达到一个稳定的FPS输出，所以我们需要采用负反馈控制系统模型。一个典型的负反馈控制系统如下图：

![负反馈控制系统\label{fig:ControlSystem}](ControlSystem.png)
<br>
&emsp;&emsp;根据负反馈控制理论，我们设计出如下的场景复杂度控制系统：
![场景复杂度控制系统\label{fig:SceneManagement}](SceneManagement.png)
&emsp;&emsp;整个系统分为三个部分：<br>
输入部分：<br>
场景输入模块，主要指的是场景对象的加载和序列化，生成CPU渲染数据等。<br>
系统指标模块，主要指的是根据硬件平台，以及玩家的设置，预先指定的游戏运行时的系统指标，包括FPS,显示特性，CPU、GPU、内存、带宽、电量消耗等数据。<br>
输出部分：<br>
场景呈现模块，主要指渲染模块。<br>
输出检测模块，主要指实际游戏运行时的系统指标，包括FPS,CPU、GPU、内存、带宽、电量消耗等数据。<br>
反馈控制部分：<br>
场景预处理模块，主要指对于场景对象的预处理，用于场景复杂度降维，把全场景复杂度降至当前视野复杂度，主要是指Visibility检测算法。<br>
反馈控制器模块，<br>
复杂度控制器模块，<br>


## 1.2 系统模块
&emsp;&emsp;从功能层面划分，具体模块组成如下
![功能模块组成\label{fig:Framework}](Framework.png)


# 2.输入模块

&emsp;&emsp;场景的复杂度，是场景中所有对象复杂度的总和。关于复杂度的定义，根据之前渲染架构一节对于硬件平台的核心资源分析，我们把对于核心资源消耗的因素，统一称作复杂度要素。
&emsp;&emsp;场景对象的复杂度，主要由Mesh，纹理，材质等核心要素决定，但在确定物件的物理复杂度之后，我们还要根据物件的距离(Distance)、屏幕占比(ScreenSize)、重要程度(根据需要人为定义，比如社交属性等)等因素计算物件的一个份量(Bucket)。<br>

## 2.1 复杂度评估
mesh 内存 带宽 gpu
纹理 带宽
材质 gpu

drawcall 状态切换 cpu gpu
静态合批，动态合批

## 2.2 Bucket计算
&emsp;&emsp;在Epic关于堡垒之夜的分享中，提到一个Bucket的概念
引擎里面有一个东西，我知道这个是比较偏向于游戏逻辑业务的概念，可能一般大家不太认为会在引擎里面实现，我们叫做重要度管理系统，大家知道游戏的常规优化手段叫做LOD，不管是面数、更新频率，我们都会根据在屏幕上所占比进行调整，这是很通用的，沿用很久的优化手段。
![Bucket1\label{fig:Bucket1}](Bucket1.jpg)
&emsp;&emsp;我们怎么样让各个游戏模块从游戏逻辑层去修正LOD的计算？这时我们引入Significance Manager，我们会分配针对每个平台的Bucket，大家可以看到右下示意图中蓝色的小点代表玩家控制的角色，边上的小点是别的玩家和交互的动态对象。我们根据离主角玩家的距离，在屏幕上的尺寸或者可见性，决定使用什么Bucket。例如基于可见性的计算，虽然离我很近，但是因为在我的背后，可能很多时候我都感受不到，Bucket就可以分得不一样，通过Bucket我们会用来控制、修正LOD的各种计算。这里是一个例子，我们这个系统本身用于我们自己比较火热的游戏《堡垒之夜》，手机、掌机、电脑都可以跑，我们兼容所有的平台可以联机玩，游戏在不同平台上的场景、复杂程度其实是一样的。
![Bucket2\label{fig:Bucket2}](Bucket2.jpg)
&emsp;&emsp;这种情况下，硬件的计算能力有非常大的差别，所以我们针对移动平台和主机Bucket也不一样，除了自身控制的角色给的Bucket比较高，剩下的角色的比较低，主机有四个，手机有一个，这个设置不仅按平台来，也可以按设备来，移动设备好的和差的硬件计算能力差很多，我们可以在Device profile指定当前这台设备Bucket的规划。



## 2.3 场景对象加载与卸载
&emsp;&emsp;场景对象的加载，有三个重要指标：加载时长、加载速度、加载的资源量<br>
在内存可控的情形下，可以适当提前进行资源加载，即内存中保持一定的冗余加载量。这可以在关卡设计时，就保持在更远的距离进行资源加载。最理想的情况下：<br>
保证即使支持的最低硬件配置也能在加载时间内可以加载完所有必须的数据。<br>
加快资源加载速度，资源加载链路可用的优化包括：优化数据存储、IO模型，尽可能减少数据解析和复制的开销、并发执行等。<br>
减少必需资源总量，这一部分可用的优化包括：优化资源重用、减少不必要的资源冗余、资源加载优先级、未加载完成时使用占位资源等等。实际上不管在使用何种方式划分关卡，总存在资源冗余的情况，而如果使用九宫格式的资源加载，其冗余资源占有量和格子大小的成正比。

&emsp;&emsp;关于游戏场景中哪些对象对于游戏玩法来说意义重大或无关紧要，有一个基本要素概念是：热区(Area of Interseting)，即玩家感兴趣的范围。对于非FPS来说，角色战斗范围不过几十米之内，大多数情况下，信息获取范围不足百米。而对于FPS来说，因为枪械有非常远的攻击距离，加上配套的多倍放大瞄准镜的设定，战斗范围可能会延伸到4、500米。我们可以优先加载影响玩法的东西和近处的东西，而远处那些不影响玩法的东西可以在加载时做分类策略：
当其是不含显示数据的功能性数据，且其不影响全局的功能状态时，不加载它。
当其包含显示数据但其画面占比贡献小(投影面积小或透明度低等)的时候，不加载它
当其包含显示数据但其画面贡献大的时候，加载它不那么精细的数据。

UE4的Mesh Lod Streaming和Texture Streaming一样是加载[RequiredLodLevel ,MaxLodLevel]的Lod集合，是因为它的流式加载实现机制中没有记录单模型被多引用的情形，所以它无法知道有哪些Lod级别是当前渲染所必须的。

## 2.5 特殊对象的处理
&emsp;&emsp;大世界场景，比较典型的场景物件有大面积地形，大规模植被等。这两类对象有屏幕占比高，实例数量多的特点，是场景复杂度的重要来源。如何处理这两类对象，降低场景复杂度，也是我们需要重点关注的内容。

### 2.5.1 Landscape 
地形系统与地形低模代理方案<br>
&emsp;&emsp;UE的地形系统，采用的是Geo-Mipmap，他的优点是LOD生成简单，顶点缓冲区、索引缓冲区可以共用等。另外,UE的地形系统，渲染单位是component，并且地表渲染用的是多层layer根据weightmap texture进行混合的方案，为了减少材质复杂度和采样数，UE会为每个component生成一个独立的material instance。基于这些实现和优化，导致了相应的缺点，如component无法合批渲染，使得大地形的DrawCall很高。LOD的区分只和屏幕占比有关，使得无法区分不同地形区域对于地形mesh的细节需求，如山丘和平地有可能使用相同的LOD,要么因为高LOD造成细节丢失，要么因为低LOD造成顶点浪费等。
&emsp;&emsp;基于上述的分析，在使用ue地形系统来构造大世界，我们选择近处使用地形系统来表现细节，远处使用地形低模代理来表现轮廓的方案。这样可以表现大世界的同时，也极大的降低了复杂度，如DrawCall,材质复杂度等。<br>

&emsp;&emsp;UE原生低模代理的生成,使用基于误差的分割策略。这样既能保证平地使用较少的顶点数，同时也能保证细节较多的地方(如山丘等)保持较好的细节。
![分割策略\label{fig:SpiltMethod}](SpiltMethod.png)

公式如下：
![分割公式\label{fig:SplitFormula}](SplitFormula.png)

地形渲染的合批方案<br>
&emsp;&emsp;虽然地形低模代理方案在一定程度上缓解了DrawCall过高的问题，但同时也会增加Mesh和纹理的使用量，本质上是一种空间换时间的方法。所以根据不同硬件平台的特性，我们需要在地形和低模代理直接取一个合适的边界。所以，我们也需要考虑地形系统自身的合批方案，从而降低地形系统自身的DrawCall消耗。根据上面对于UE地形系统的分析，我们可以使用Virtual Texture,把地形渲染时需要的纹理统一通过VT来存储，因此相同LOD的地形component可以合批渲染。
&emsp;&emsp;VT是比较成熟的渲染技术，这里不过多阐述，需要注意的是要进行压缩格式的处理，比如ASTC，否则带宽消耗会比较可观，下图是VT原理示意图：
![vt\label{fig:virtualtexture}](virtualtexture.png)

### 2.5.2 Foliage 
&emsp;&emsp;UE的植被方案采用的是HISM，内部实现采用K-D Tree来管理实例对象，相对于他的基类ISM，他能够支持分簇LOD实例进行渲染，这个特性使得它比较适合一定范围内植被对象的管理和渲染。但是当范围增大，植被实例增加，HISM导致的CPU、GPU消耗都会极具增加。常用的解决方案是增加植被static mesh的LOD区分力度，也无法很好的缓解这个问题，同时还会引起中远景的植被表现力急剧下降。<br>
&emsp;&emsp;下图是hism渲染示意图：
![hism\label{fig:hism}](hism.png)

降低实际的植被数据，不破坏显示效果<br>
<br>
Imposter方案<br>
增强表现力<br>
降低DrawCall与对象复杂度<br>
![植被Imposter\label{fig:imposter}](imposter.png)
![植被ImposterDiffuse\label{fig:ImposterDiffuse}](ImposterDiffuse.png)
![植被ImposterNormal\label{fig:ImposterNormal}](ImposterNormal.png)
![植被ImposterSSS\label{fig:ImposterSSS}](ImposterSSS.png)


# 3.控制器/被控对象模块

## 3.1 复杂度控制本质
对象lod
加载、卸载
显示、隐藏
优化dc,在空间和时间取得平衡

其他优化手段诸如gpu driven，本质上是增加剔除的精确性、减少剔除消耗、利用indirect command和vt减少渲染时cpu与gpu的交互损耗以及状态切换损耗

## 3.2 Visibility检测
&emsp;&emsp;Visibility检测属于场景预处理模块，需要说明的是，他属于Runtime阶段的预处理。实际上，我们可以增加离线预处理模块，即离线检测工具，主要用于自动分析场景各区域复杂度，帮助设计人员更有效的设计场景内容。UE已经集成了一定功能的复杂度离线检测工具，用于检测mesh的顶点数、内存占用、纹理、光照贴图、材质等信息。
&emsp;&emsp;UE目前已经集成了多种

## 3.4 场景对象显示与隐藏
## 3.5 LOD策略
## 3.6 其他调节策略



# 4.输出/反馈模块
## 4.2 输出与反馈数据采集

## 4.3 反馈控制器算法

~~~
enum EPerformanceWarningLevel
{
	NoWarning,
	ThrottlingImminent,
	Throttling,
}

enum EPerformanceBottleneckType
{
	CPU
	GPU,
	Memory,
	TargetFrameRate,
};

/**
 * 
 */
class NGR_API FPerformanceController
{
public:
	FPerformanceController();
	~FPerformanceController();

	bool PreferRaiseLevels();
	bool CanLowerLOD();

	void RaiseGPULevel();
	void LowerGPULevel();
	void RaiseCPULevel();
	void LowerCPULevel();

	void RaiseLOD();
	void LowerLOD();

protected:
	int cpuLevel;
	int gpuLevel;

	int maxCPULevel;
	int maxGPULevel;
};
~~~

# 5.总结

